// 设计模式

// 设计原则
// 单一职责原则
// 最少前提原则
// 开放-封闭原则
// 好莱坞原则 - 高阶调用低阶

// 面向接口编程
// 面向过程编程
// AOP编程
// 面向对象编程  举例 案例

// 代码重构
// 条件分支   提炼函数 退出嵌套 合并重复片段
// 循环       合理使用循环 退出多重循环
// 提炼函数 链式调用  参数对象options/config


// js常见设计模式  结构 意图 案例
// 单例模式      保证一个类有且仅有一个实例供使用
// 策略模式      封装不同算法，环境类接收请求
// 代理模式      为实现关键功能的本体做一层包装   虚拟代理，延迟开销；缓存代理；
// 迭代器模式    提供一种访问集合中元素的方式     可迭代对象 内部迭代器 外部迭代器
// 发布-订阅模式 定义一对多的依赖关系             js事件模式（订阅）
// 命令模式      执行特定指令                    命令对象 receiver对象  执行/撤销/排队
// 组合模式      用子对象构建大对象               宏命令，树结构 聚合关系 叶-树一致对待
// 模板方法      js用高阶函数更好
// 享元模式      共享对象，用于性能优化减少内存占用 内部状态，外部状态   对象池 HTTP连接池 数据库连接池
// 职责链模式    请求在对象间传递并处理           灵活拆分链节点
// 中介着模式    增加中介者对象，多对多变为一对多
// 装饰着模式    为对象动态加入新属性或新行为
// 状态模式      优秀的设计模式，封装状态对象，内部状态/外部行为/状态切换
// 适配器模式    已有接口不匹配问题

// 包装模式   适配器模式 装饰者模式 代理模式 外观模式
// 设计模式  -- 针对特定问题的优雅方案
// 分辨模式的关键是意图 - 创建型模式 结构型模式 行为型模式


// 经典案例 总结回顾















